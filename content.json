{"meta":{"title":"NgAgo","subtitle":"","description":"","author":"NgAgo","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"C++中关于父类函数在子类指针向上造型中overload函数被调用的研究","slug":"C-中关于父类函数在子类指针向上造型中overload函数被调用的研究","date":"2019-11-07T02:15:13.000Z","updated":"2019-11-07T02:16:27.332Z","comments":true,"path":"2019/11/07/C-中关于父类函数在子类指针向上造型中overload函数被调用的研究/","link":"","permalink":"http://yoursite.com/2019/11/07/C-%E4%B8%AD%E5%85%B3%E4%BA%8E%E7%88%B6%E7%B1%BB%E5%87%BD%E6%95%B0%E5%9C%A8%E5%AD%90%E7%B1%BB%E6%8C%87%E9%92%88%E5%90%91%E4%B8%8A%E9%80%A0%E5%9E%8B%E4%B8%ADoverload%E5%87%BD%E6%95%B0%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E7%A0%94%E7%A9%B6/","excerpt":"","text":"C++中关于父类函数在子类指针向上造型中overload函数被调用的研究 首先看一个现象两个类1234567class A&#123; public: A():i(0）&#123;cout&lt;&lt;&quot;A::A()&quot;&lt;&lt;endl;&#125; void f()&#123;cout&lt;&lt;&quot;A::f()&quot;&lt;&lt;endl;&#125; int i;&#125;; 123456class B:public A&#123; public: int j; B():&#123;cout&lt;&lt;&quot;B::B()&quot;&lt;&lt;endl;&#125; void f()&#123;cout&lt;&lt;&quot;B::f()&quot;&lt;&lt;j&lt;&lt;endl;&#125;&#125;; main()12345678int mian()&#123; A a; B b; A *p=&amp;b; cout&lt;&lt;&quot;p:&quot;&lt;&lt;p&lt;&lt;endl; p-&gt;f();&#125; PS:这里两个类一个A为B的父类，main函数中做的是B类的地址传给A类的指针（向上造型：upcast），然后通过这个指针调用f()函数。 What I want to do ? 这个地方有个问题就是我通过这个指针调用的f（）是A的还是B的？因为这里的f（）是overload的。这里就是想知道调用的那个？看运行结果 1A::A() 这里可以看出调用的是A类的函数 那么this指针是不是指向对象b的呢？如果是那A类的f（）是否可以操作b中的成员呢？修改一下程序 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;class A&#123; public: A():i(0)&#123;&#125; void f()&#123;int *p =&amp;i;cout&lt;&lt;&quot;A::f()&quot;&lt;&lt;*p&lt;&lt;&quot; &quot;&lt;&lt;&quot;this:&quot;&lt;&lt;this&lt;&lt;endl;&#125; int i;&#125;;class B:public A&#123; public: int j; B()&#123;i=10;&#125; public: void f()&#123;cout&lt;&lt;&quot;B::f()&quot;&lt;&lt;endl;&#125;&#125;;int main()&#123; A a; B b; A *p=&amp;b; cout&lt;&lt;&quot;p:&quot;&lt;&lt;p&lt;&lt;endl; p-&gt;f();&#125; 在A::f()中创造一个指针，指向this指向的对象的成员变量“i ”，为了区别a对象里面的“ i ”我们在B::B()里让i=10;结果如下： 12p:0x7fffc2f06cccA::f()10 this:0x7fffc2f06ccc 可见this指向了a并且A::f()是作用在a上了。 这也说明了this这个指针不能绝对的叫”自引用指针“，毕竟在B类里面没有A::f()（overlode）。 结论 两个类中在子类和父类中如果有overlode的现象通过upcasting的一个指针调用的overload函数，是调用其父类中那个函数，不是调用子类的函数，如果想调用子类的函数可以通过对象.f（）的形式调用或者利用多态性，在每个overload的函数前面加virtual关键字然后用upcasting的指针来调用。并且这种二元的关系可以推广到多元的关系，读者可以自行证明，由于篇幅过长这里就不做赘述了。 感想多态的意义就是让同一个动作不同的派生类可能细节上不同或者算法上不同，所以就让类本身去完成，而程序员只关心到底是谁而已。所以在多态中合理的利用upcast和virtual是很关键的。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-11-04T12:47:07.142Z","updated":"2019-11-04T12:47:07.143Z","comments":true,"path":"2019/11/04/hello-world/","link":"","permalink":"http://yoursite.com/2019/11/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}