{"meta":{"title":"NgAgo","subtitle":"","description":"","author":"NgAgo","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"关于静态对象和静态成员的学习总结","slug":"关于静态对象和静态成员变量的学习总结","date":"2019-11-07T14:16:10.000Z","updated":"2019-11-07T14:32:20.002Z","comments":true,"path":"2019/11/07/关于静态对象和静态成员变量的学习总结/","link":"","permalink":"http://yoursite.com/2019/11/07/%E5%85%B3%E4%BA%8E%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","excerpt":"静态学习总结","text":"静态学习总结 被static定义变量就是全区变量只是全局变量的scope是在整个程序的，static的变量的scope是在“函数”，“类”中，仅仅只是scope不同罢了。 1.制造一个静态对象 12345678class A&#123; public: void f(); private: int a;&#125;;static A a; 这里static A a 是建立在全区中的一个变量，并且构造是在main函数之前完成的，其空间是在link的时候分配好了，析构则是在程序结束的时候执行。 在一个.cpp文件中有多个全局对象，他们的初始化是不知道先后顺序的，如果初始化之间是有依赖，并且在多个.cpp文件里面，这样是无法进行初始化，编译器做不到。要么相互之间不要有依赖，要么吧所有依赖的初始化全部放在同一个文件里面。或者像java一样没有全局变量不设置静态对象。 2.静态成员 静态成员变量 12345678class A&#123; public: void f(); private: static int a;&#125;;A::a=10; 我们只能在类外面对这个静态变量做定义不能在构造函数中或者在initializer list中做初始化，前者因为在类只是在声明，只是告诉编译器有一个变量 a 是静态变量而具体的空间是没有被分配的，而定义只能在类外面完成，对隐式声明也是如此（也是在类里面）。这就如同exturn int i;一样。 后者是因为initializer list只能对非静态的成员做初始化 静态成员函数 1234567891011class A&#123; public: static void f(); private: static int a;&#125;;int main()&#123; A::f()//可以直接调用&#125; 静态成员函数只能调用静态成员变量，因为静态成员函数不需要this就可以调用，而且对于静态成员函数this是的确不存在的，而没有this的原因也是我们需要这个静态成员函数在没有对象的时候也能被调用。","categories":[],"tags":[]},{"title":"C++中关于父类函数在子类指针向上造型中overload函数被调用的研究","slug":"C-中关于父类函数在子类指针向上造型中overload函数被调用的研究","date":"2019-11-07T02:15:13.000Z","updated":"2019-11-07T11:25:53.497Z","comments":true,"path":"2019/11/07/C-中关于父类函数在子类指针向上造型中overload函数被调用的研究/","link":"","permalink":"http://yoursite.com/2019/11/07/C-%E4%B8%AD%E5%85%B3%E4%BA%8E%E7%88%B6%E7%B1%BB%E5%87%BD%E6%95%B0%E5%9C%A8%E5%AD%90%E7%B1%BB%E6%8C%87%E9%92%88%E5%90%91%E4%B8%8A%E9%80%A0%E5%9E%8B%E4%B8%ADoverload%E5%87%BD%E6%95%B0%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E7%A0%94%E7%A9%B6/","excerpt":"C++中关于父类函数在子类指针向上造型中overload函数被调用的研究","text":"C++中关于父类函数在子类指针向上造型中overload函数被调用的研究 首先看一个现象两个类1234567class A&#123; public: A():i(0）&#123;cout&lt;&lt;&quot;A::A()&quot;&lt;&lt;endl;&#125; void f()&#123;cout&lt;&lt;&quot;A::f()&quot;&lt;&lt;endl;&#125; int i;&#125;; 123456class B:public A&#123; public: int j; B():&#123;cout&lt;&lt;&quot;B::B()&quot;&lt;&lt;endl;&#125; void f()&#123;cout&lt;&lt;&quot;B::f()&quot;&lt;&lt;j&lt;&lt;endl;&#125;&#125;; main()12345678int mian()&#123; A a; B b; A *p=&amp;b; cout&lt;&lt;&quot;p:&quot;&lt;&lt;p&lt;&lt;endl; p-&gt;f();&#125; PS:这里两个类一个A为B的父类，main函数中做的是B类的地址传给A类的指针（向上造型：upcast），然后通过这个指针调用f()函数。 What I want to do ? 这个地方有个问题就是我通过这个指针调用的f（）是A的还是B的？因为这里的f（）是overload的。这里就是想知道调用的那个？看运行结果 1A::A() 这里可以看出调用的是A类的函数 那么this指针是不是指向对象b的呢？如果是那A类的f（）是否可以操作b中的成员呢？修改一下程序 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;class A&#123; public: A():i(0)&#123;&#125; void f()&#123;int *p =&amp;i;cout&lt;&lt;&quot;A::f()&quot;&lt;&lt;*p&lt;&lt;&quot; &quot;&lt;&lt;&quot;this:&quot;&lt;&lt;this&lt;&lt;endl;&#125; int i;&#125;;class B:public A&#123; public: int j; B()&#123;i=10;&#125; public: void f()&#123;cout&lt;&lt;&quot;B::f()&quot;&lt;&lt;endl;&#125;&#125;;int main()&#123; A a; B b; A *p=&amp;b; cout&lt;&lt;&quot;p:&quot;&lt;&lt;p&lt;&lt;endl; p-&gt;f();&#125; 在A::f()中创造一个指针，指向this指向的对象的成员变量“i ”，为了区别a对象里面的“ i ”我们在B::B()里让i=10;结果如下： 12p:0x7fffc2f06cccA::f()10 this:0x7fffc2f06ccc 可见this指向了a并且A::f()是作用在a上了。 这也说明了this这个指针不能绝对的叫”自引用指针“，毕竟在B类里面没有A::f()（overlode）。 结论 两个类中在子类和父类中如果有overlode的现象通过upcasting的一个指针调用的overload函数，是调用其父类中那个函数，不是调用子类的函数，如果想调用子类的函数可以通过对象.f（）的形式调用或者利用多态性，在每个overload的函数前面加virtual关键字然后用upcasting的指针来调用。并且这种二元的关系可以推广到多元的关系，读者可以自行证明，由于篇幅过长这里就不做赘述了。 感想多态的意义就是让同一个动作不同的派生类可能细节上不同或者算法上不同，所以就让类本身去完成，而程序员只关心到底是谁而已。所以在多态中合理的利用upcast和virtual是很关键的。","categories":[],"tags":[]}]}